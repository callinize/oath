<h2>lib/oath.js</h2><div id="comments"><div class="comment"><div class="summary"><h1>Oath constructor</h1></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">Object</span>}
<span class="name">options</span><span class="description"></span></li></ul><div class="body"><p>Create a new promise.</p>

<h4>Options</h4>

<ul>
<li>parent - used internally for chaining</li>
<li>...</li>
</ul>

<h4>You can use <code>Oath</code> within single functions</h4>

<pre><code> var promise = new oath();
 promise.then(successFn, errorFn);
 myAsycFunction(function(err, result) {
   if (err) promise.reject(err);
   promise.resolve(result);
 });
</code></pre>

<h4>Or return them to ease chaining of callbacks</h4>

<pre><code> function doSomething(data) {
   var promise = new oath();
   // async stuff here
   // promise should be returned immediately
   return promise;
 }

 doSomething(data).then(successFn, errorFn);
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>function Oath (options) {
  var self = this;
  options = options || {};
  
  this.pending = [];
  this._options = {
    parent: options.parent || null
  };</code></pre></div><div class="comment"><h3>this.resolve()</h3><div class="summary"><h2>Oath#resolve</h2></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">Object</span>}
<span class="name">result</span><span class="description"></span></li></ul><div class="body"><p>Emits completion event to execute <code>success</code> chain of functions.</p>

<pre><code>   // When async work is complete
   promise.resolve(my_data_obj);
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>this.resolve = function (result) {
    self.complete('resolve', result);
  };</code></pre></div><div class="comment"><h3>this.reject()</h3><div class="summary"><h2>Oath#reject</h2></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">Object</span>}
<span class="name">result</span><span class="description"></span></li></ul><div class="body"><p>Emit completion event to execute <code>failure</code> chain of functions.</p>

<pre><code>   // When async work errors
   promise.reject(my_error_obj);
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>this.reject = function (result) {
    self.complete('reject', result);
  };
}</code></pre></div><div class="comment"><h3>Oath.prototype.then()</h3><div class="summary"><h1>then</h1></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">Function</span>}
<span class="name">success</span><span class="description">will execute on `resolve` </span></li><li><span class="type">param:</span>{
<span class="types">Function</span>}
<span class="name">failure</span><span class="description">will execute on `reject` (optional)</span></li></ul><div class="body"><p>Chainable function for promise observers to queue result functions.</p>

<pre><code> doSomething(my_data)
   .then(successFn1, failureFn1)
   .then(successFn2, failureFn2)
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>Oath.prototype.then = function (success, failure) {
  this.pending.push({ resolve: success, reject: failure });
  return this;
};</code></pre></div><div class="comment"><h3>Oath.prototype.get()</h3><div class="summary"><h1>get</h1></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">String</span>}
<span class="name">property</span><span class="description"></span></li></ul><div class="body"><p>On <code>resolve</code>, will return <code>property</code> value from data passed by oath. Subsequent <code>then</code> calls will <br />have the value of the <code>get</code> passed to them.</p>

<pre><code> doSomething(my_data).get('doctor')
   .then(function(doctor) { ... })
   .then(function(doctor) { ... });
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>Oath.prototype.get = function (property) {
  var o = new Oath({ parent: this });
  this.then(
    function(value) { o.resolve(value[property]); },
    function(value) { o.reject(value); }
  );
  return o;
};</code></pre></div><div class="comment"><h3>Oath.prototype.pop()</h3><div class="summary"><h1>pop</h1></div><ul class="tags"></ul><div class="body"><p>Return you to a parent oath if you have chained down.</p>

<pre><code> doSomething(my_data)
   .get('doctor')
     .then(function(doctor) { ... })
     .pop()
   .then(function(my_data) { ... });
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>Oath.prototype.pop = function () {
  if (this._options.parent) {
    return this._options.parent;
  } else {
    return this;
  }
};</code></pre></div><div class="comment"><h3>Oath.prototype.call()</h3><div class="summary"><h1>call</h1></div><ul class="tags"><li><span class="type">param:</span>{
<span class="types">String</span>}
<span class="name">function</span><span class="description">name</span></li></ul><div class="body"><p>On <code>resolve</code>, will execute a function of <code>name</code> in the result object. The function that is called <br />will be passed all subseqents parameters of <code>oath.call</code>. The context of <code>this</code> in the function <br />that is called will be equal to the <code>result</code> object passed on <code>oath.resolve</code>.</p>

<pre><code> // queue up call on complete
 oath.call('validate', '1234');

 oath.resolve({ some: 'data'
   , validate: function (apiKey) { 
       this.some == 'data'; 
       apiKey == '1234';
       ... 
     }
   });
</code></pre></div><a href="#" class="button view-source">view source</a><pre class="source"><code>Oath.prototype.call = function (fn) {
  var args = arguments;
  return this.then(function(value) {
    return value[fn].apply(value, Array.prototype.slice.call(args, 1));
  });
};</code></pre></div></div>